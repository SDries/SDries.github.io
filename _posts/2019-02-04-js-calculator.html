---
title: Vanilla js calculator
thumbnail: -SITE_URL-/images/calculator.jpg
excerpt: "A copy of the windows calculator functionality. It is meant to be an exercise in vanilla javascript."
# githublink: "#"
bitbucketlink: "https://bitbucket.org/Dries_Sercu/vanilla-js-calculator"
demolink: "-SITE_URL-/projects/vanilla-js-calculator/index.html"
---
<p>
	It had been a while since I made anything using javascript. As an exercise I reproduced as much of the windows calculator functionality as possible.
</p>
<p>
	I decided against using a framework because I wanted to focus on javascript instead of some framework. Using a framework might have made this easier but the focus of the exercise would have been different.
</p>
<p>
	While I was at it I also decided to write tests and to generate reports about my tests.
</p>
<p>
	The calculator has some nice features, and it's been a nice study in user experience.
</p>

<h2>Jasmine</h2>

<p>
	From previous experience i learned that, without realizing it, you will break your own application.
	To make sure I could break pieces without knowing about it something was required to verify that every piece of code worked as expected.
	Furthermore, the faster I knew something broke, the better. Using any testing framework prevents you from having to go to your browser and clicking every button every time you make a change.
	With this in mind I implemented <a href="https://jasmine.github.io/">Jasmine</a>.
</p>
<p class="quote">
	"Jasmine is a behavior-driven development framework for testing JavaScript code."
</p>
<p>
	In practice, this means that anytime I modified my code Jasmine would tell me whether or not my code still worked. There's a catch though, I have to tell Jasmine what to test. This means that if I forget something or I make a mistake in one of my tests, this will be reflected in the report.
</p>
<p>
	A best practices when writing tests for your code is to write them before you write the code that will be tested.
</p>
{% include post-image.html image-link="-SITE_URL-/images/js-calculator-jasmine-test-example.png" image-description="When things go wrong jasmine lets you know what test went wrong and why." %}

<h2>Istanbul</h2>

<p>
	To be absolutely sure that I tested everything in my application I generated reports using <a href="https://istanbul.js.org/">Istanbul</a>. Because I didn't write tests to check whether DOM manipulation (e.g. pressing a button changes the display of the calculator) worked I didn't achieve 100%.
</p>
<p class="quote">
	Istanbul instruments your ES5 and ES2015+ JavaScript code with line counters, so that you can track how well your unit-tests exercise your codebase.
</p>
{% include post-image.html image-link="-SITE_URL-/images/js-calculator-istanbul-1.png" image-description="Selecting the file will show you in depth what lines were tested."  %}
{% include post-image.html image-link="-SITE_URL-/images/js-calculator-istanbul-2.jpg" image-description="Green lines have been tested, red lines haven't"  %}

<h2>Quirks</h2>

<p>
	Some things weren't foreseen but are very interesting, these have been documented in the readme file (click view source). Try calculating 21.6 + 0.8.
</p>
<p>
	I also noticed that the windows calculator doesn't give multiplication precedence over addition. 1 + 1 + 1 * 2 = 4 and not 6. So, there you have it, a bug in the windows calculator that isn't in mine.
</p>